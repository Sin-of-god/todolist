#include <stdio.h>
#include <stdlib.h>
 
// Node
typedef struct node {
    int data;
 
    // Lower values indicate higher priority
    int priority;
 
    struct node* next;
 
} Node;
 
// Function to Create A New Node
Node* newNode(int d, int p)
{
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->data = d;
    temp->priority = p;
    temp->next = NULL;
 
    return temp;
}
 
// Return the value at head
int peek(Node** head)
{
    return (*head)->data;
}
 
// Removes the element with the
// highest priority form the list
void pop(Node** head)
{
    Node* temp = *head;
    (*head) = (*head)->next;
    free(temp);
}
 
// Function to push according to priority
void push(Node** head, int d, int p)
{
    Node* start = (*head);
 
    // Create new Node
    Node* temp = newNode(d, p);
 
    // Special Case: The head of list has lesser
    // priority than new node. So insert new
    // node before head node and change head node.
    if ((*head)->priority > p) {
 
        // Insert New Node before head
        temp->next = *head;
        (*head) = temp;
    }
    else {
 
        // Traverse the list and find a
        // position to insert new node
        while (start->next != NULL &&
            start->next->priority < p) {
            start = start->next;
        }
 
        // Either at the ends of the list
        // or at required position
        temp->next = start->next;
        start->next = temp;
    }
}
 
// Function to check is list is empty
int isEmpty(Node** head)
{
    return (*head) == NULL;
}
 
// Driver code
int main()
{
    // Create a Priority Queue
    // 7->4->5->6
    Node* pq = newNode(4, 1);
    push(&pq, 5, 2);
    push(&pq, 6, 3);
    push(&pq, 7, 0);
 
    while (!isEmpty(&pq)) {
        printf("%d ", peek(&pq));
        pop(&pq);
    }
 
    return 0;
}



# include<stdio.h>  
# include<malloc.h>  
  
typedef struct node  
    {  
    int priority;  
    int info;  
    struct node *link;  
}NODE;  
NODE *front = NULL;  
  
// insert method  
void insert(int data,int priority)  
{  
    NODE *temp,*q;  
  
    temp = (NODE *)malloc(sizeof(NODE));  
    temp->info = data;  
    temp->priority = priority;  
    // condition to check whether the first element is empty or the element to be inserted has more priority than the first element  
    if( front == NULL || priority < front->priority )  
    {  
        temp->link = front;  
        front = temp;  
    }  
    else  
    {  
        q = front;  
        while( q->link != NULL && q->link->priority <= priority )  
            q=q->link;  
        temp->link = q->link;  
        q->link = temp;  
    }  
}  
  
// delete method  
  
void del()  
{  
    NODE *temp;  
        // condition to check whether the Queue is empty or not  
    if(front == NULL)  
        printf("Queue Underflow\n");  
    else  
    {  
        temp = front;  
        printf("Deleted item is %d\n", temp->info);  
        front = front->link;  
        free(temp);  
    }  
  
// display method  
void display()  
{  
    NODE *ptr;  
    ptr = front;  
    if(front == NULL)  
        printf("Queue is empty\n");  
    else  
    {     
        printf("Queue is :\n");  
        printf("Priority       Item\n");  
        while(ptr != NULL)  
        {  
            printf("%5d        %5d\n",ptr->priority,ptr->info);  
            ptr = ptr->link;  
        }  
    }  
}  
/*End of display*/  
  
// main method  
int main()  
{  
    int choice, data, priority;  
    do  
    {  
        printf("1.Insert\n");  
        printf("2.Delete\n");  
        printf("3.Display\n");  
        printf("4.Quit\n");  
        printf("Enter your choice : ");  
        scanf("%d", &choice);  
        switch(choice)  
        {  
            case 1:  
                printf("Enter the data which is to be added in the queue : ");  
                scanf("%d",&data);  
                printf("Enter its priority : ");  
                scanf("%d",&priority);  
                insert(data,priority);  
                break;  
            case 2:  
                del();  
                break;  
            case 3:  
                display();  
                break;  
            case 4:  
            break;  
                default :  
                printf("Wrong choice\n");  
        }  
    }while(choice!=4);  
  
    return 0;  
}  
